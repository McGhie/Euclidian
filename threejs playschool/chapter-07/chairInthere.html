<!DOCTYPE html>

<html>

<head>
    <title>CZ Trial</title>
    <script type="text/javascript" src="../libs/three.js"></script>
	<script type="text/javascript" src="aicause.22.json"></script>
    <script type="text/javascript" src="../libs/stats.js"></script>
    <script type="text/javascript" src="../libs/dat.gui.js"></script>
	
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">
	var scene, camera, renderer;

    // I guess we need this stuff too
    var container, HEIGHT,
        WIDTH, fieldOfView, aspectRatio,
        nearPlane, farPlane, stats,
        geometry, particleCount,
        i, h, color, size,
        materials = [],
        mouseX = 0,
        mouseY = 0,
        windowHalfX, windowHalfY, cameraZ,
        fogHex, fogDensity, parameters = {},
        parameterCount, particles;
		
    
    function init() {

        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        windowHalfX = WIDTH / 2;
        windowHalfY = HEIGHT / 2;

        fieldOfView = 25;
        aspectRatio = WIDTH / HEIGHT;
        nearPlane = 1;
        farPlane = 10000;

        /* 	fieldOfView — Camera frustum vertical field of view.
	aspectRatio — Camera frustum aspect ratio.
	nearPlane — Camera frustum near plane.
	farPlane — Camera frustum far plane.

	- http://threejs.org/docs/#Reference/Cameras/PerspectiveCamera

	In geometry, a frustum (plural: frusta or frustums)
	is the portion of a solid (normally a cone or pyramid)
	that lies between two parallel planes cutting it. - wikipedia.		*/

        cameraZ = farPlane / 1; /*	So, 1000? Yes! move on!	*/
        fogHex = 0x000000; /* As black as your heart.	*/
        fogDensity = 0.00007; /* So not terribly dense?	*/

        camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);
        camera.position.z = 10000;
		
        scene = new THREE.Scene();
		scene.fog = new THREE.FogExp2(fogHex, fogDensity);
		var plane = new THREE.Mesh(
		    new THREE.PlaneGeometry(10000,1000,1),
             new THREE.MeshDepthMaterial()
			 );
       scene.add(plane);		
        

        geometry = new THREE.Geometry(); /*	NO ONE SAID ANYTHING ABOUT MATH! UGH!	*/

		var mydata=JSON.parse(data)	;
		particleCount=Object.keys(mydata).length;
		//alert(particleCount);
        //particleCount = 20000; /* Leagues under the sea */

        
var Coef = 1500;
        for (i = 0; i < particleCount; i++) {
			var coOrd=mydata[i].DP.split(",");
			//alert(coOrd[0]);
            var vertex = new THREE.Vector3();
			
			vertex.x = Math.abs(coOrd[0]) * Coef; 
			vertex.y = Math.abs(coOrd[1])*Coef;
			vertex.z = Math.abs(coOrd[2])*Coef;
			Coef=Coef+.001;
			/*alert(vertex.x);
			alert(vertex.y);
			alert(vertex.z);*/
			console.log(i+": "+vertex.x +", "+vertex.y +", "+vertex.z+"\n")
            geometry.vertices.push(vertex);
        }

        /*	We can't stop here, this is bat country!	*/

        parameters = [
            [
                [1, 1, 0.5], 10
            ],
            [
                [0.95, 1, 0.5], 4
            ],
            [
                [0.90, 1, 0.5], 3
            ],
            [
                [0.85, 1, 0.5], 2
            ],
            [
                [0.80, 1, 0.5], 1
            ]
        ];
        parameterCount = parameters.length;

      i=0;
     //   for (i = 0; i < parameterCount; i++) {

            color = parameters[i][0];
          //  size = parameters[i][1];
			
			
            materials[i] = new THREE.PointCloudMaterial({
                size: size
            });

            particles = new THREE.PointCloud(geometry, materials[i]);

          //  particles.rotation.x = Math.random() * 6;
           // particles.rotation.y =  200000;
           // particles.rotation.z = Math.random() * 6;

            scene.add(particles);
     //   }

      
        renderer = new THREE.WebGLRenderer(); /*	Rendererererers particles.	*/
      // renderer.setPixelRatio(window.devicePixelRatio); /*	Probably 1; unless you're fancy.	*/
        renderer.setSize(WIDTH, HEIGHT); /*	Full screen baby Wooooo!	*/

        document.getElementById("WebGL-output").appendChild(renderer.domElement);

       
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        stats.domElement.style.right = '0px';
        document.getElementById("Stats-output").appendChild(stats.domElement);

        /* Event Listeners */

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('touchstart', onDocumentTouchStart, false);
        document.addEventListener('touchmove', onDocumentTouchMove, false);
		 
		animate(); 
		function animate() {
			requestAnimationFrame(animate);
			render();
			stats.update();
		}
		
		function render() {
        var time = Date.now() * 0.00005;

        //camera.position.x += (mouseX - camera.position.x) * 1.1;
        //camera.position.y += (-mouseY - camera.position.y) * 0.2;
        //camera.position.z += (-mouseY - camera.position.z) * 1.0;
		
		camera.position.x = 800;;
        camera.position.y = 1500;
        //camera.position.z = 5000;
		
	  // console.log(camera.position.z + "\n");
	   
        camera.lookAt(scene.position);

        for (i = 0; i < scene.children.length; i++) {

            var object = scene.children[i];

            if (object instanceof THREE.PointCloud) {
           //object.rotation.y=4500;
			object.rotation.y = time * (i < 4 ? i + 1 : -(i + 1));
			   object.rotation.z = time * (i < 4 ? i + 1 : -(i + 1));
            object.rotation.x = time * (i < 4 ? i + 1 : -(i + 1));
			// console.log(object.rotation.y + "\n");
            }
        }

        for (i = 0; i < materials.length; i++) {

            color = parameters[i][0];

            h = (180 * (color[0] + time) % 180) / 180;
            materials[i].color.setHSL(h, color[1], color[2]);
        }

        renderer.render(scene, camera);
    }

    function onDocumentMouseMove(e) {
        mouseX = e.clientX - windowHalfX;
        mouseY = e.clientY - windowHalfY;
    }

    /*	Mobile users?  I got your back homey	*/

    function onDocumentTouchStart(e) {

        if (e.touches.length === 1) {

            e.preventDefault();
            mouseX = e.touches[0].pageX - windowHalfX;
            mouseY = e.touches[0].pageY - windowHalfY;
        }
    }

    function onDocumentTouchMove(e) {

        if (e.touches.length === 1) {

            e.preventDefault();
            mouseX = e.touches[0].pageX - windowHalfX;
            mouseY = e.touches[0].pageY - windowHalfY;
        }
    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

		
    }

   
    window.onload = init;
</script>
</body>
</html>